const express = require('express')
const Photo = require('../db/photoModel')
const { authenticateToken } = require('../middleware/auth')
const multer = require('multer')
const path = require('path')
const fs = require('fs')
const router = express.Router()

// Configure multer for file storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Use the images directory in the frontend/public folder
    const imagesDir = path.join(__dirname, '../../frontend/public/images')

    // Check if the directory exists, if not create it
    if (!fs.existsSync(imagesDir)) {
      fs.mkdirSync(imagesDir, { recursive: true })
    }

    cb(null, imagesDir)
  },
  filename: (req, file, cb) => {
    // Generate a unique filename: timestamp + original extension
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9)
    const ext = path.extname(file.originalname)
    cb(null, uniqueSuffix + ext)
  }
})

// File filter to accept only images
const fileFilter = (req, file, cb) => {
  // Accept only image files
  if (file.mimetype.startsWith('image/')) {
    cb(null, true)
  } else {
    cb(new Error('Only image files are allowed!'), false)
  }
}

// Initialize multer with configuration
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB file size limit
  }
})

// Handle Multer errors
const handleMulterErrors = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ error: 'File too large. Maximum size is 5MB.' })
    }
    return res.status(400).json({ error: err.message })
  } else if (err) {
    return res.status(400).json({ error: err.message })
  }
  next()
}

// Route for uploading photos - authentication required
router.post(
  '/upload',
  authenticateToken,
  upload.single('photo'),
  handleMulterErrors,
  async (request, response) => {
    try {
      // Check if file was uploaded
      if (!request.file) {
        return response.status(400).json({ error: 'No file uploaded' })
      }

      // Get user ID from authenticated user or request body
      const user_id = request.user.id || request.body.user_id

      if (!user_id) {
        return response.status(400).json({ error: 'User ID is required' })
      }

      // Create a new photo document
      const newPhoto = new Photo({
        file_name: request.file.filename, // The unique filename generated by multer
        user_id: user_id,
        date_time: new Date(),
        comments: []
      })

      // Save the photo to the database
      const savedPhoto = await newPhoto.save()

      response.status(201).json(savedPhoto)
    } catch (error) {
      console.error('Error uploading photo:', error)
      response.status(500).json({ error: 'Internal server error' })
    }
  }
)

router.post('/', async (request, response) => {
  try {
    const { file_name, user_id } = request.body

    if (!file_name || !user_id) {
      return response.status(400).json({ error: 'Missing required fields: file_name and user_id' })
    }

    const newPhoto = new Photo({
      file_name,
      user_id,
      date_time: new Date(),
      comments: []
    })

    const savedPhoto = await newPhoto.save()
    response.status(201).json(savedPhoto)
  } catch (error) {
    console.error('Error creating photo:', error)
    response.status(500).json({ error: 'Internal server error' })
  }
})

// Get photo by ID
router.get('/:id', async (request, response) => {
  try {
    const photoId = request.params.id

    const photo = await Photo.findById(photoId)
      .populate({
        path: 'comments.user_id',
        select: '_id first last_name'
      })
      .populate({
        path: 'user_id',
        select: '_id first last_name'
      })
      .select('_id file_name date_time user_id comments')

    if (!photo) {
      return response.status(404).json({ error: 'Photo not found' })
    }

    // Transform the data to include full user info in comments
    const photoObj = photo.toObject()

    // Transform comments to include user info
    if (photoObj.comments && photoObj.comments.length > 0) {
      photoObj.comments = photoObj.comments.map(comment => ({
        _id: comment._id,
        comment: comment.comment,
        date_time: comment.date_time,
        user: comment.user_id
          ? {
              _id: comment.user_id._id,
              first: comment.user_id.first,
              last_name: comment.user_id.last_name
            }
          : null
      }))
    }

    response.status(200).json(photoObj)
  } catch (error) {
    console.error('Error fetching photo:', error)
    if (error.name === 'CastError') {
      return response.status(400).json({ error: 'Invalid photo ID format' })
    }
    response.status(500).json({ error: 'Internal server error' })
  }
})

// Get all photos of a specific user
router.get('/photosOfUser/:id', async (request, response) => {
  try {
    const userId = request.params.id

    // Find all photos belonging to the user
    // Populate user information for each comment
    const photos = await Photo.find({ user_id: userId })
      .populate({
        path: 'comments.user_id',
        select: '_id first last_name'
      })
      .select('_id file_name date_time user_id comments')
      .sort({ date_time: -1 }) // Sort by newest first

    // Transform the data to include full user info in comments
    const photosWithComments = photos.map(photo => {
      const photoObj = photo.toObject()

      // Transform comments to include user info
      if (photoObj.comments && photoObj.comments.length > 0) {
        photoObj.comments = photoObj.comments.map(comment => ({
          _id: comment._id,
          comment: comment.comment,
          date_time: comment.date_time,
          user: comment.user_id
            ? {
                _id: comment.user_id._id,
                first: comment.user_id.first,
                last_name: comment.user_id.last_name
              }
            : null
        }))
      }

      return photoObj
    })

    response.status(200).json(photosWithComments)
  } catch (error) {
    console.error('Error fetching photos of user:', error)
    if (error.name === 'CastError') {
      return response.status(400).json({ error: 'Invalid user ID format' })
    }
    response.status(500).json({ error: 'Internal server error' })
  }
})

module.exports = router
